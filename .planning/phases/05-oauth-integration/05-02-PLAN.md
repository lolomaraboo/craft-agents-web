---
phase: 05-oauth-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/web/src/server/routes/api/oauth/index.ts
  - apps/web/src/server/routes/api/oauth/google.ts
  - apps/web/src/server/routes/api/oauth/slack.ts
  - apps/web/src/server/routes/api/oauth/microsoft.ts
  - apps/web/src/server/routes/api/index.ts
autonomous: true

must_haves:
  truths:
    - "User can initiate Google OAuth flow and receive callback with tokens"
    - "User can initiate Slack OAuth flow with HTTPS relay and receive callback"
    - "User can initiate Microsoft OAuth flow with PKCE and receive callback"
    - "Tokens are stored in credential manager with encryption"
    - "Expired tokens can be refreshed using refresh token"
  artifacts:
    - path: "apps/web/src/server/routes/api/oauth/google.ts"
      provides: "Google OAuth start and callback routes"
      exports: ["googleOAuthRoutes"]
    - path: "apps/web/src/server/routes/api/oauth/slack.ts"
      provides: "Slack OAuth start and callback routes"
      exports: ["slackOAuthRoutes"]
    - path: "apps/web/src/server/routes/api/oauth/microsoft.ts"
      provides: "Microsoft OAuth start and callback routes"
      exports: ["microsoftOAuthRoutes"]
    - path: "apps/web/src/server/routes/api/oauth/index.ts"
      provides: "OAuth route registration"
      exports: ["oauthRoutes"]
  key_links:
    - from: "apps/web/src/server/routes/api/oauth/google.ts"
      to: "@craft-agent/shared/auth"
      via: "import token exchange and refresh functions"
      pattern: "refreshGoogleToken|GOOGLE_SERVICE_SCOPES"
    - from: "apps/web/src/server/routes/api/oauth/google.ts"
      to: "apps/web/src/server/lib/oauth-state.ts"
      via: "state tracking"
      pattern: "oauthStateManager\\.(createState|getSessionForState|clearState)"
    - from: "apps/web/src/server/routes/api/oauth/google.ts"
      to: "@craft-agent/shared/credentials"
      via: "token storage"
      pattern: "getCredentialManager"
---

<objective>
Implement OAuth routes for Google, Slack, and Microsoft providers with start endpoints, callback handlers, and token storage.

Purpose: Enable browser OAuth flows for all three providers. Each provider has a /start endpoint that returns an auth URL, and a /callback endpoint that exchanges the authorization code for tokens and stores them encrypted.

Output: Three provider route files with start/callback handlers, registered under /api/oauth/{provider}/
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-oauth-integration/05-RESEARCH.md

# Prior plan summary (OAuth infrastructure)
@.planning/phases/05-oauth-integration/05-01-SUMMARY.md

# Existing OAuth implementations to adapt
@packages/shared/src/auth/google-oauth.ts
@packages/shared/src/auth/slack-oauth.ts
@packages/shared/src/auth/microsoft-oauth.ts
@packages/shared/src/auth/pkce.ts

# Credential manager for token storage
@packages/shared/src/credentials/index.ts

# API routes index (where to register oauth routes)
@apps/web/src/server/routes/api/index.ts

# OAuth state manager from 05-01
@apps/web/src/server/lib/oauth-state.ts

# OAuth schemas from 05-01
@apps/web/src/server/schemas/oauth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google OAuth routes</name>
  <files>
    apps/web/src/server/routes/api/oauth/google.ts
  </files>
  <action>
Create `apps/web/src/server/routes/api/oauth/google.ts`:

1. Import dependencies:
   - fastify-plugin, FastifyPluginAsync
   - URL from 'url'
   - crypto.randomBytes, crypto.createHash
   - oauthStateManager from '../../lib/oauth-state.js'
   - TypeBox schemas from '../../schemas/oauth.js'
   - GOOGLE_SERVICE_SCOPES, getGoogleScopes, refreshGoogleToken from '@craft-agent/shared/auth'
   - getCredentialManager from '@craft-agent/shared/credentials'
   - getConfig from '../../lib/config.js'

2. Constants (from env vars):
   ```typescript
   const GOOGLE_CLIENT_ID = process.env.GOOGLE_OAUTH_CLIENT_ID || ''
   const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_OAUTH_CLIENT_SECRET || ''
   const GOOGLE_AUTH_URL = 'https://accounts.google.com/o/oauth2/v2/auth'
   const GOOGLE_TOKEN_URL = 'https://oauth2.googleapis.com/token'
   const GOOGLE_USERINFO_URL = 'https://www.googleapis.com/oauth2/v2/userinfo'
   ```

3. Helper function `generatePKCE()`:
   - verifier = randomBytes(32).toString('base64url')
   - challenge = createHash('sha256').update(verifier).digest('base64url')
   - Return { verifier, challenge }

4. Route GET /google/start:
   - Query params: sessionId (required), service (optional, defaults to 'gmail')
   - Check if GOOGLE_CLIENT_ID is set, return 503 if not configured
   - Generate PKCE pair
   - Create state via oauthStateManager.createState(sessionId, 'google')
   - Get scopes using getGoogleScopes({ service })
   - Build redirect_uri: `${config.serverUrl}/api/oauth/google/callback`
   - Build authUrl with all params (client_id, redirect_uri, response_type=code, scope, state, code_challenge, code_challenge_method=S256, access_type=offline, prompt=consent)
   - Store PKCE verifier in signed cookie 'google_pkce_verifier' (maxAge: 5 min)
   - Return { authUrl, state }

5. Route GET /google/callback:
   - Query params: code, state, error, error_description
   - If error, return HTML error page
   - Validate state via oauthStateManager.getSessionForState(state)
   - If invalid state, return 400 error
   - Get PKCE verifier from cookie
   - Exchange code for tokens (POST to GOOGLE_TOKEN_URL with client_id, client_secret, code, code_verifier, grant_type, redirect_uri)
   - Fetch user email from GOOGLE_USERINFO_URL
   - Store tokens in credential manager using sessionId as workspaceId:
     ```typescript
     const credManager = getCredentialManager()
     await credManager.set(
       { type: 'google_oauth', workspaceId: sessionId, name: email },
       {
         value: tokens.accessToken,
         refreshToken: tokens.refreshToken,
         expiresAt: tokens.expiresAt
       }
     )
     ```
   - Clear state and PKCE cookie
   - Return HTML success page with "You can close this window" message

6. Export as fastify-plugin wrapped function `googleOAuthRoutes`
  </action>
  <verify>
    bun run --cwd apps/web tsc --noEmit
  </verify>
  <done>
    Google OAuth routes compile without errors, start generates auth URL, callback exchanges code for tokens
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Slack and Microsoft OAuth routes</name>
  <files>
    apps/web/src/server/routes/api/oauth/slack.ts
    apps/web/src/server/routes/api/oauth/microsoft.ts
  </files>
  <action>
**Create `apps/web/src/server/routes/api/oauth/slack.ts`:**

Similar structure to Google, but with Slack-specific differences:

1. Constants:
   ```typescript
   const SLACK_CLIENT_ID = process.env.SLACK_OAUTH_CLIENT_ID || ''
   const SLACK_CLIENT_SECRET = process.env.SLACK_OAUTH_CLIENT_SECRET || ''
   const SLACK_AUTH_URL = 'https://slack.com/oauth/v2/authorize'
   const SLACK_TOKEN_URL = 'https://slack.com/api/oauth.v2.access'
   ```

2. Route GET /slack/start:
   - No PKCE (Slack doesn't support it)
   - Generate state only
   - Get scopes using SLACK_SERVICE_SCOPES from @craft-agent/shared/auth
   - **Important:** Use Cloudflare relay for redirect_uri:
     ```typescript
     const config = getConfig()
     // Slack requires HTTPS - relay through Cloudflare Worker
     const redirectUri = `https://agents.craft.do/auth/slack/callback?port=${new URL(config.serverUrl).port}`
     ```
   - Build authUrl with user_scope (not scope) for user token
   - Return { authUrl, state }

3. Route GET /slack/callback:
   - Exchange code using HTTP Basic auth (client_id:client_secret base64 encoded)
   - Token response contains `authed_user.access_token` (not top-level access_token)
   - Store with teamId as additional metadata
   - Return HTML success page

**Create `apps/web/src/server/routes/api/oauth/microsoft.ts`:**

Similar to Google with Microsoft-specific differences:

1. Constants:
   ```typescript
   const MICROSOFT_CLIENT_ID = process.env.MICROSOFT_OAUTH_CLIENT_ID || ''
   const MICROSOFT_AUTH_URL = 'https://login.microsoftonline.com/common/oauth2/v2.0/authorize'
   const MICROSOFT_TOKEN_URL = 'https://login.microsoftonline.com/common/oauth2/v2.0/token'
   const MICROSOFT_GRAPH_ME_URL = 'https://graph.microsoft.com/v1.0/me'
   ```

2. Route GET /microsoft/start:
   - PKCE required (same as Google)
   - Scopes must include 'offline_access' for refresh tokens
   - Build authUrl with response_mode=query, prompt=consent
   - Store PKCE verifier in cookie 'microsoft_pkce_verifier'

3. Route GET /microsoft/callback:
   - No client_secret in token exchange (pure PKCE for public clients)
   - Get email from Graph API /me endpoint (mail or userPrincipalName)
   - Store tokens in credential manager

Export both as fastify-plugin wrapped functions.
  </action>
  <verify>
    bun run --cwd apps/web tsc --noEmit
  </verify>
  <done>
    Slack and Microsoft OAuth routes compile, handle provider-specific auth flows
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OAuth route index and register in API</name>
  <files>
    apps/web/src/server/routes/api/oauth/index.ts
    apps/web/src/server/routes/api/index.ts
  </files>
  <action>
1. Create `apps/web/src/server/routes/api/oauth/index.ts`:

```typescript
import fp from 'fastify-plugin'
import type { FastifyPluginAsync } from 'fastify'
import { googleOAuthRoutes } from './google.js'
import { slackOAuthRoutes } from './slack.js'
import { microsoftOAuthRoutes } from './microsoft.js'

const oauthRoutesImpl: FastifyPluginAsync = async (fastify) => {
  // Register provider routes under /oauth prefix
  await fastify.register(googleOAuthRoutes, { prefix: '/oauth' })
  await fastify.register(slackOAuthRoutes, { prefix: '/oauth' })
  await fastify.register(microsoftOAuthRoutes, { prefix: '/oauth' })

  fastify.log.info('OAuth routes registered: /api/oauth/{google,slack,microsoft}/{start,callback}')
}

export const oauthRoutes = fp(oauthRoutesImpl, {
  name: 'oauth-routes',
  fastify: '5.x'
})
```

2. Update `apps/web/src/server/routes/api/index.ts`:
   - Import `oauthRoutes` from './oauth/index.js'
   - Add registration after existing routes:
     ```typescript
     await fastify.register(oauthRoutes, { prefix: '/api' })  // OAuth flows (05-01)
     ```

3. Verify the route structure:
   - GET /api/oauth/google/start -> initiates Google OAuth
   - GET /api/oauth/google/callback -> handles Google callback
   - GET /api/oauth/slack/start -> initiates Slack OAuth
   - GET /api/oauth/slack/callback -> handles Slack callback
   - GET /api/oauth/microsoft/start -> initiates Microsoft OAuth
   - GET /api/oauth/microsoft/callback -> handles Microsoft callback
  </action>
  <verify>
    cd /opt/craft-agents-web/apps/web && bun run dev &
    sleep 3
    # Test Google start endpoint returns 503 (not configured) - proves route exists
    curl -s "http://localhost:3000/api/oauth/google/start?sessionId=test" | grep -E '(error|authUrl)'
    pkill -f "bun run dev" || true
  </verify>
  <done>
    All OAuth routes registered at /api/oauth/{provider}/{start,callback}, server starts and routes respond
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `bun run --cwd apps/web tsc --noEmit`
2. Server starts with OAuth routes registered
3. Each provider's /start endpoint:
   - Returns 503 if credentials not configured
   - Returns authUrl with correct provider-specific parameters when configured
4. Each provider's /callback endpoint:
   - Validates state parameter
   - Exchanges code for tokens
   - Stores tokens in credential manager
   - Returns HTML success/error page
</verification>

<success_criteria>
- All three providers (Google, Slack, Microsoft) have start and callback routes
- OAuth routes registered under /api/oauth/{provider}/
- Token exchange works with provider-specific logic (PKCE for Google/Microsoft, Basic auth for Slack)
- Tokens stored encrypted via credential manager
- Slack uses HTTPS relay pattern for redirect URI
- HTML response pages for callback success/failure
</success_criteria>

<output>
After completion, create `.planning/phases/05-oauth-integration/05-02-SUMMARY.md`
</output>
