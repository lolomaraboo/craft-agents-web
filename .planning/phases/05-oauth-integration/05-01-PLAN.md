---
phase: 05-oauth-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/src/server/index.ts
  - apps/web/src/server/plugins/oauth.ts
  - apps/web/src/server/lib/oauth-state.ts
  - apps/web/src/server/schemas/oauth.ts
autonomous: true
user_setup:
  - service: google
    why: "OAuth credentials for Google APIs"
    env_vars:
      - name: GOOGLE_OAUTH_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials"
      - name: GOOGLE_OAUTH_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials"
    dashboard_config:
      - task: "Add http://localhost:3000/api/oauth/google/callback to authorized redirect URIs"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
  - service: microsoft
    why: "OAuth credentials for Microsoft Graph APIs"
    env_vars:
      - name: MICROSOFT_OAUTH_CLIENT_ID
        source: "Azure Portal -> App registrations -> Application (client) ID"
    dashboard_config:
      - task: "Add http://localhost:3000/api/oauth/microsoft/callback to redirect URIs"
        location: "Azure Portal -> App registrations -> Authentication"
  - service: slack
    why: "OAuth credentials for Slack APIs"
    env_vars:
      - name: SLACK_OAUTH_CLIENT_ID
        source: "Slack API -> Your Apps -> OAuth & Permissions"
      - name: SLACK_OAUTH_CLIENT_SECRET
        source: "Slack API -> Your Apps -> OAuth & Permissions"
  - service: fastify-cookie
    why: "Secure cookie signing for OAuth state"
    env_vars:
      - name: COOKIE_SECRET
        source: "Generate with: openssl rand -hex 32"

must_haves:
  truths:
    - "User can start an OAuth flow and be redirected to the provider's consent page"
    - "User's OAuth state is tracked securely for 5 minutes during the flow"
    - "Invalid or expired OAuth states are rejected with clear error messages"
  artifacts:
    - path: "apps/web/src/server/plugins/oauth.ts"
      provides: "Fastify plugin with cookie and OAuth2 registration"
      exports: ["oauthPlugin"]
    - path: "apps/web/src/server/lib/oauth-state.ts"
      provides: "OAuth state management with session tracking"
      exports: ["OAuthStateManager", "oauthStateManager"]
    - path: "apps/web/src/server/schemas/oauth.ts"
      provides: "TypeBox schemas for OAuth routes"
      exports: ["OAuthCallbackQuery", "OAuthStartQuery", "OAuthStartResponse"]
  key_links:
    - from: "apps/web/src/server/plugins/oauth.ts"
      to: "@fastify/cookie"
      via: "fastify.register"
      pattern: "fastify\\.register.*fastifyCookie"
    - from: "apps/web/src/server/lib/oauth-state.ts"
      to: "crypto"
      via: "randomBytes for state generation"
      pattern: "randomBytes.*toString"
---

<objective>
Create OAuth infrastructure for Fastify: plugin with cookie support, state manager for session tracking, and TypeBox schemas for OAuth routes.

Purpose: Foundation for all three OAuth provider integrations (Google, Slack, Microsoft). The state manager enables tracking which session initiated an OAuth flow so callbacks know where to store tokens.

Output: OAuth plugin, state manager singleton, and request/response schemas ready for provider routes.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-oauth-integration/05-RESEARCH.md

# Server entry point (add oauth plugin here)
@apps/web/src/server/index.ts

# Existing OAuth code to reference for patterns
@packages/shared/src/auth/pkce.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install OAuth dependencies and create TypeBox schemas</name>
  <files>
    apps/web/package.json
    apps/web/src/server/schemas/oauth.ts
  </files>
  <action>
1. Install dependencies in apps/web:
   ```bash
   cd apps/web && bun add @fastify/oauth2@8.1.2 @fastify/cookie@11.0.2
   ```

2. Create `apps/web/src/server/schemas/oauth.ts` with TypeBox schemas:

   - OAuthStartQuery: optional `sessionId` (string) and optional `service` (string for provider-specific services like 'gmail', 'calendar')
   - OAuthStartResponse: `authUrl` (string), `state` (string)
   - OAuthCallbackQuery: `code` (string), `state` (string), optional `error` (string), optional `error_description` (string)
   - OAuthSuccessResponse: `success` (true), `email` (optional string), `provider` (string)
   - OAuthErrorResponse: `success` (false), `error` (string)

Use Type.Union for OAuthCallbackQuery to handle both success (code+state) and error (error+state) cases.
  </action>
  <verify>
    bun run --cwd apps/web tsc --noEmit
  </verify>
  <done>
    OAuth schemas export OAuthStartQuery, OAuthStartResponse, OAuthCallbackQuery, OAuthSuccessResponse, OAuthErrorResponse
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OAuth state manager</name>
  <files>
    apps/web/src/server/lib/oauth-state.ts
  </files>
  <action>
Create `apps/web/src/server/lib/oauth-state.ts` implementing OAuthStateManager class:

1. Interface OAuthStateEntry: `{ sessionId: string; expiresAt: number; provider: string }`

2. Class OAuthStateManager:
   - Private `stateMap: Map<string, OAuthStateEntry>`
   - Private `cleanupInterval: NodeJS.Timeout | null`

3. Methods:
   - `createState(sessionId: string, provider: string): string`
     - Generate 16-byte random state using crypto.randomBytes().toString('hex')
     - Store in map with 5-minute expiry (Date.now() + 5 * 60 * 1000)
     - Return state string

   - `getSessionForState(state: string): { sessionId: string; provider: string } | null`
     - Lookup in map
     - Return null if not found or expired (Date.now() > entry.expiresAt)
     - Return { sessionId, provider } if valid

   - `clearState(state: string): void`
     - Delete from map

   - `startCleanup(): void`
     - Start interval (every 60 seconds) to delete expired entries
     - Store interval reference for cleanup

   - `stopCleanup(): void`
     - Clear the interval if running

4. Export singleton instance `oauthStateManager` (create new OAuthStateManager and call startCleanup)

Reference packages/shared/src/auth/pkce.ts for randomBytes pattern.
  </action>
  <verify>
    bun run --cwd apps/web tsc --noEmit
  </verify>
  <done>
    OAuthStateManager creates/validates/clears state with 5-minute expiry and periodic cleanup
  </done>
</task>

<task type="auto">
  <name>Task 3: Create OAuth plugin and register in server</name>
  <files>
    apps/web/src/server/plugins/oauth.ts
    apps/web/src/server/index.ts
  </files>
  <action>
1. Create `apps/web/src/server/plugins/oauth.ts`:

```typescript
import fp from 'fastify-plugin'
import type { FastifyPluginAsync } from 'fastify'
import fastifyCookie from '@fastify/cookie'
import { getConfig } from '../lib/config.js'

const oauthPluginImpl: FastifyPluginAsync = async (fastify) => {
  const config = getConfig()

  // Cookie plugin is required by @fastify/oauth2 v7.2.0+ for secure state storage
  // COOKIE_SECRET must be set in environment for signed cookies
  const cookieSecret = process.env.COOKIE_SECRET
  if (!cookieSecret) {
    fastify.log.warn('COOKIE_SECRET not set - OAuth flows will not work securely')
  }

  await fastify.register(fastifyCookie, {
    secret: cookieSecret || 'insecure-dev-secret-change-me',
    hook: 'onRequest',
    parseOptions: {
      httpOnly: true,
      secure: !config.isDev, // Secure in production only
      sameSite: 'lax',
    }
  })

  fastify.log.info('OAuth plugin registered with cookie support')
}

export const oauthPlugin = fp(oauthPluginImpl, {
  name: 'oauth-plugin',
  fastify: '5.x'
})
```

2. Update `apps/web/src/server/index.ts`:
   - Import `oauthPlugin` from './plugins/oauth.js'
   - Register it AFTER corsPlugin and BEFORE apiRoutes:
     ```typescript
     // Register OAuth plugin (cookie support for OAuth state)
     await fastify.register(oauthPlugin)
     ```

Note: We're NOT using @fastify/oauth2's built-in provider registration here. The RESEARCH.md recommends custom routes because:
- Slack needs HTTPS relay which @fastify/oauth2 doesn't handle
- We want to reuse existing @craft-agent/shared token exchange logic
- Custom routes give us more control over the flow

The cookie plugin is the key dependency - it enables secure state/PKCE storage in httpOnly cookies.
  </action>
  <verify>
    cd /opt/craft-agents-web/apps/web && bun run dev &
    sleep 2
    curl -s http://localhost:3000/api/sessions | head -1
    pkill -f "bun run dev" || true
  </verify>
  <done>
    OAuth plugin registers successfully, server starts without errors, cookie support enabled
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `bun run --cwd apps/web tsc --noEmit`
2. Server starts successfully with OAuth plugin
3. OAuth schemas are importable and type-correct
4. State manager creates unique states and respects expiry
</verification>

<success_criteria>
- @fastify/oauth2 and @fastify/cookie installed in apps/web/package.json
- OAuth plugin registered in server index.ts
- State manager singleton exported and functional
- TypeBox schemas ready for route handlers
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-oauth-integration/05-01-SUMMARY.md`
</output>
