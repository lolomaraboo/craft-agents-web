---
phase: 04-file-handling
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/web/src/server/routes/api/attachments.ts
  - apps/web/src/server/lib/file-cleanup.ts
  - apps/web/src/server/index.ts
autonomous: true

must_haves:
  truths:
    - "User can download previously uploaded attachments via GET request"
    - "Download endpoint validates file path is within session directory"
    - "Orphaned files are identified by comparing filesystem to session.jsonl"
    - "Cleanup utility removes files older than grace period"
  artifacts:
    - path: "apps/web/src/server/routes/api/attachments.ts"
      provides: "Download endpoint for session attachments"
      contains: "GET.*attachmentId"
    - path: "apps/web/src/server/lib/file-cleanup.ts"
      provides: "Orphan detection and cleanup utility"
      exports: ["cleanupOrphanedFiles", "scheduleCleanup"]
  key_links:
    - from: "apps/web/src/server/routes/api/attachments.ts"
      to: "@craft-agent/shared/sessions/storage"
      via: "loadSession for attachment lookup"
      pattern: "loadSession"
    - from: "apps/web/src/server/lib/file-cleanup.ts"
      to: "@craft-agent/shared/sessions/storage"
      via: "listSessions, loadSession for reference check"
      pattern: "listSessions|loadSession"
    - from: "apps/web/src/server/index.ts"
      to: "apps/web/src/server/lib/file-cleanup.ts"
      via: "cleanup schedule initialization"
      pattern: "scheduleCleanup"
---

<objective>
Implement file download endpoint with path validation and orphaned file cleanup utility.

Purpose: Complete file handling by enabling downloads and preventing disk bloat from orphaned attachments.

Output: Working GET /api/sessions/:id/attachments/:attachmentId endpoint and scheduled cleanup job.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-file-handling/04-RESEARCH.md
@.planning/phases/04-file-handling/04-01-SUMMARY.md

# Files created in 04-01
@apps/web/src/server/routes/api/attachments.ts
@apps/web/src/server/schemas/attachment.ts
@apps/web/src/server/lib/file-validator.ts

# Shared package utilities
@packages/shared/src/sessions/storage.ts (loadSession, listSessions, getSessionAttachmentsPath)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add download endpoint to attachments route</name>
  <files>
    apps/web/src/server/routes/api/attachments.ts
  </files>
  <action>
Add GET /sessions/:sessionId/attachments/:attachmentId endpoint to existing attachments.ts:

1. Import additional dependencies:
   - resolve, dirname from 'path'
   - createReadStream from 'fs'
   - existsSync from 'fs'
   - loadSession from @craft-agent/shared/sessions/storage

2. Add download endpoint:
   ```typescript
   server.get(
     '/sessions/:sessionId/attachments/:attachmentId',
     {
       schema: {
         params: Type.Object({
           sessionId: Type.String(),
           attachmentId: Type.String(),
         }),
         querystring: Type.Object({
           download: Type.Optional(Type.String()),
         }),
         response: {
           404: ErrorResponseSchema,
           403: ErrorResponseSchema,
           500: ErrorResponseSchema,
         },
       },
     },
     async (request, reply) => { ... }
   )
   ```

3. Implementation:
   a. Load session using loadSession(workspaceRootPath, sessionId)
   b. If session not found, return 404
   c. Search session.messages for attachment with matching ID:
      - Iterate messages, check message.attachments array
      - Find attachment where a.id === attachmentId
   d. If attachment not found, return 404
   e. Validate file exists: existsSync(attachment.storedPath)
   f. Security check - validate path is within session attachments dir:
      ```typescript
      const attachmentsDir = getSessionAttachmentsPath(workspaceRootPath, sessionId)
      const resolvedPath = resolve(attachment.storedPath)
      if (!resolvedPath.startsWith(resolve(attachmentsDir))) {
        return reply.code(403).send({ error: 'Access denied' })
      }
      ```
   g. Set Content-Type header from attachment.mimeType
   h. Set Content-Disposition based on ?download query param:
      - If present: `attachment; filename="${attachment.name}"`
      - If absent: `inline; filename="${attachment.name}"`
   i. Stream file: `return reply.send(createReadStream(attachment.storedPath))`

Reference RESEARCH.md Pattern 2 (File Download with Content-Disposition) and "File Download with Authentication" code example.
  </action>
  <verify>
    - `bun run typecheck` passes
    - Upload a test file, note the attachment ID from response
    - Download: `curl http://localhost:3000/api/sessions/test-session/attachments/{id} -v`
    - Verify Content-Type header matches file type
    - Force download: `curl http://localhost:3000/api/sessions/test-session/attachments/{id}?download -v`
    - Verify Content-Disposition: attachment header
  </verify>
  <done>
    - GET /api/sessions/:sessionId/attachments/:attachmentId returns file content
    - Path traversal attacks blocked by directory prefix check
    - Content-Type set from stored mimeType
    - ?download query param forces download vs inline display
  </done>
</task>

<task type="auto">
  <name>Task 2: Create orphaned file cleanup utility</name>
  <files>
    apps/web/src/server/lib/file-cleanup.ts
    apps/web/src/server/index.ts
  </files>
  <action>
1. Create `apps/web/src/server/lib/file-cleanup.ts`:

   Import:
   - listSessions, loadSession, getSessionAttachmentsPath, getWorkspacePath from @craft-agent/shared/sessions/storage
   - readdir, stat, unlink from 'fs/promises'
   - existsSync from 'fs'
   - join from 'path'

   Export async function `cleanupOrphanedFiles(workspaceRootPath: string): Promise<{ removedCount: number }>`:
   a. Build set of all referenced attachment paths:
      ```typescript
      const referencedPaths = new Set<string>()
      const sessions = listSessions(workspaceRootPath)
      for (const sessionMeta of sessions) {
        const session = loadSession(workspaceRootPath, sessionMeta.id)
        if (session) {
          for (const message of session.messages) {
            if (message.attachments) {
              for (const attachment of message.attachments) {
                referencedPaths.add(attachment.storedPath)
              }
            }
          }
        }
      }
      ```
   b. Iterate session directories, find files not in referencedPaths
   c. Apply 24-hour grace period:
      ```typescript
      const stats = await stat(filepath)
      const ageHours = (Date.now() - stats.mtimeMs) / (1000 * 60 * 60)
      if (ageHours > 24) {
        await unlink(filepath)
        removedCount++
      }
      ```
   d. Return { removedCount }

   Export function `scheduleCleanup(workspaceRootPath: string, intervalHours: number = 24)`:
   - Use setInterval to run cleanupOrphanedFiles periodically
   - Log cleanup results
   - Return cleanup interval ID for potential cancellation

2. Update `apps/web/src/server/index.ts`:
   - Import scheduleCleanup from lib/file-cleanup
   - After server starts (in ready callback), call scheduleCleanup with 24-hour interval
   - Use default workspace path: ~/.craft-agent
   - Log that cleanup scheduler started

Reference RESEARCH.md Pattern 4 (Orphaned File Cleanup).
  </action>
  <verify>
    - `bun run typecheck` passes
    - Server starts and logs "Orphan cleanup scheduled" message
    - Manual test: Create orphan file in attachments dir, wait (or modify mtime), run cleanup manually
  </verify>
  <done>
    - cleanupOrphanedFiles scans sessions and removes unreferenced files
    - 24-hour grace period prevents deleting in-progress uploads
    - Cleanup scheduled to run every 24 hours on server start
    - Cleanup results logged for monitoring
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Server starts and logs cleanup scheduler initialization
2. TypeCheck passes: `bun run typecheck`
3. Full upload/download flow:
   ```bash
   # Upload
   echo "test content" > /tmp/test.txt
   RESPONSE=$(curl -s -X POST http://localhost:3000/api/sessions/test-session/attachments \
     -F "files=@/tmp/test.txt")
   ATTACHMENT_ID=$(echo $RESPONSE | jq -r '.attachments[0].id')

   # Download
   curl http://localhost:3000/api/sessions/test-session/attachments/$ATTACHMENT_ID -o /tmp/downloaded.txt
   diff /tmp/test.txt /tmp/downloaded.txt  # Should be identical
   ```
4. Path traversal blocked:
   ```bash
   curl http://localhost:3000/api/sessions/test-session/attachments/../../etc/passwd -v
   # Should return 404 (not found) or 403 (forbidden), NOT file contents
   ```
</verification>

<success_criteria>
- Download endpoint streams files with correct Content-Type
- Path traversal attacks return 403/404 (not file contents)
- Content-Disposition header respects ?download query param
- Cleanup utility identifies orphaned files via session.jsonl comparison
- 24-hour grace period prevents premature deletion
- Cleanup runs on schedule after server start
</success_criteria>

<output>
After completion, create `.planning/phases/04-file-handling/04-02-SUMMARY.md`
</output>
