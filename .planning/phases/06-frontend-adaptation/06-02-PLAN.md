---
phase: 06-frontend-adaptation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/web/src/client/components/NetworkErrorBoundary.tsx
  - apps/web/src/client/components/LoadingState.tsx
  - apps/web/src/client/components/index.ts
  - apps/web/src/client/hooks/useSessionEvents.ts
  - apps/web/src/client/hooks/useApiClient.ts
  - apps/web/src/client/hooks/index.ts
  - apps/web/src/client/main.tsx
  - apps/web/src/client/App.tsx
  - apps/web/package.json
autonomous: false

must_haves:
  truths:
    - "App bootstraps with HttpAdapter injected as window.electronAPI"
    - "NetworkErrorBoundary catches fetch errors and shows retry UI"
    - "LoadingState component shows spinner during async operations"
    - "useSessionEvents hook subscribes to WebSocket events with cleanup"
    - "User can test connection via WebSocket and see session list via HTTP"
  artifacts:
    - path: "apps/web/src/client/components/NetworkErrorBoundary.tsx"
      provides: "Error boundary for network failures"
      exports: ["NetworkErrorBoundary"]
    - path: "apps/web/src/client/components/LoadingState.tsx"
      provides: "Reusable loading indicator"
      exports: ["LoadingState"]
    - path: "apps/web/src/client/hooks/useSessionEvents.ts"
      provides: "Hook for WebSocket event subscription"
      exports: ["useSessionEvents"]
    - path: "apps/web/src/client/main.tsx"
      provides: "Bootstrap with adapter injection"
      contains: "window.electronAPI = adapter"
  key_links:
    - from: "apps/web/src/client/main.tsx"
      to: "adapters/http-adapter.ts"
      via: "import and instantiation"
      pattern: "new HttpAdapter"
    - from: "apps/web/src/client/App.tsx"
      to: "window.electronAPI"
      via: "API calls"
      pattern: "window\\.electronAPI"
    - from: "apps/web/src/client/components/NetworkErrorBoundary.tsx"
      to: "react-error-boundary"
      via: "ErrorBoundary wrapper"
      pattern: "ErrorBoundary"
---

<objective>
Wire the frontend with loading states, error boundaries, and adapter bootstrap.

Purpose: Complete the frontend adaptation by connecting HttpAdapter to the React app, adding async operation handling (loading states), and graceful error recovery (error boundaries). This makes the web frontend functional with the server APIs.

Output: Working React app that injects HttpAdapter, shows loading during fetches, handles network errors gracefully, and can display real data from the server.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-frontend-adaptation/06-RESEARCH.md
@.planning/phases/06-frontend-adaptation/06-01-SUMMARY.md

# Adapter created in Plan 01
@apps/web/src/client/adapters/http-adapter.ts
@apps/web/src/client/adapters/websocket-manager.ts
@apps/web/src/client/types/electron-api.ts

# Current web client files
@apps/web/src/client/main.tsx
@apps/web/src/client/App.tsx

# Electron renderer patterns to follow
@apps/electron/src/renderer/hooks/useNotifications.ts
@apps/electron/src/renderer/contexts/NavigationContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-error-boundary and create utility components</name>
  <files>
    apps/web/package.json
    apps/web/src/client/components/NetworkErrorBoundary.tsx
    apps/web/src/client/components/LoadingState.tsx
    apps/web/src/client/components/index.ts
  </files>
  <action>
Install dependency and create reusable components:

1. **Install react-error-boundary:**
   ```bash
   cd apps/web && bun add react-error-boundary
   ```

2. **apps/web/src/client/components/NetworkErrorBoundary.tsx:**
   ```typescript
   import { ErrorBoundary, FallbackProps } from 'react-error-boundary'
   import { ReactNode } from 'react'

   function NetworkErrorFallback({ error, resetErrorBoundary }: FallbackProps) {
     const isNetworkError =
       error.message?.includes('fetch') ||
       error.message?.includes('NetworkError') ||
       error.message?.includes('Failed to')

     return (
       <div style={{
         display: 'flex',
         flexDirection: 'column',
         alignItems: 'center',
         justifyContent: 'center',
         padding: '2rem',
         textAlign: 'center'
       }}>
         <div style={{ color: '#dc2626', fontSize: '1.125rem', fontWeight: 600, marginBottom: '0.5rem' }}>
           {isNetworkError ? 'Connection Error' : 'Something went wrong'}
         </div>
         <p style={{ color: '#6b7280', marginBottom: '1rem' }}>
           {isNetworkError
             ? 'Unable to connect to the server. Please check your connection.'
             : error.message}
         </p>
         <button
           onClick={resetErrorBoundary}
           style={{
             padding: '0.5rem 1rem',
             backgroundColor: '#3b82f6',
             color: 'white',
             border: 'none',
             borderRadius: '0.375rem',
             cursor: 'pointer'
           }}
         >
           Try Again
         </button>
       </div>
     )
   }

   interface Props {
     children: ReactNode
     onReset?: () => void
   }

   export function NetworkErrorBoundary({ children, onReset }: Props) {
     return (
       <ErrorBoundary
         FallbackComponent={NetworkErrorFallback}
         onReset={onReset}
         onError={(error, info) => {
           console.error('[NetworkErrorBoundary]', error, info)
         }}
       >
         {children}
       </ErrorBoundary>
     )
   }
   ```

3. **apps/web/src/client/components/LoadingState.tsx:**
   ```typescript
   import { ReactNode } from 'react'

   interface Props {
     isLoading: boolean
     children: ReactNode
     message?: string
     inline?: boolean
   }

   export function LoadingState({ isLoading, children, message, inline }: Props) {
     if (!isLoading) return <>{children}</>

     if (inline) {
       return (
         <span style={{ display: 'inline-flex', alignItems: 'center', gap: '0.5rem', color: '#6b7280' }}>
           <Spinner size={16} />
           {message || 'Loading...'}
         </span>
       )
     }

     return (
       <div style={{
         display: 'flex',
         flexDirection: 'column',
         alignItems: 'center',
         justifyContent: 'center',
         padding: '2rem'
       }}>
         <Spinner size={32} />
         <span style={{ color: '#6b7280', marginTop: '0.5rem' }}>{message || 'Loading...'}</span>
       </div>
     )
   }

   function Spinner({ size = 24 }: { size?: number }) {
     return (
       <svg
         width={size}
         height={size}
         viewBox="0 0 24 24"
         fill="none"
         style={{ animation: 'spin 1s linear infinite' }}
       >
         <circle
           cx="12"
           cy="12"
           r="10"
           stroke="currentColor"
           strokeWidth="4"
           strokeLinecap="round"
           strokeDasharray="31.4 31.4"
           style={{ opacity: 0.25 }}
         />
         <circle
           cx="12"
           cy="12"
           r="10"
           stroke="currentColor"
           strokeWidth="4"
           strokeLinecap="round"
           strokeDasharray="31.4 31.4"
           strokeDashoffset="23.55"
         />
         <style>{`
           @keyframes spin {
             from { transform: rotate(0deg); }
             to { transform: rotate(360deg); }
           }
         `}</style>
       </svg>
     )
   }
   ```

4. **apps/web/src/client/components/index.ts:**
   ```typescript
   export { NetworkErrorBoundary } from './NetworkErrorBoundary'
   export { LoadingState } from './LoadingState'
   ```
  </action>
  <verify>
`bun run typecheck 2>&1 | grep -E "^apps/web"` - No type errors
`grep "react-error-boundary" apps/web/package.json` - Dependency added
`ls apps/web/src/client/components/` - Shows NetworkErrorBoundary.tsx, LoadingState.tsx, index.ts
  </verify>
  <done>react-error-boundary installed, NetworkErrorBoundary wraps children with retry UI, LoadingState shows spinner during async operations</done>
</task>

<task type="auto">
  <name>Task 2: Create hooks for API client and session events</name>
  <files>
    apps/web/src/client/hooks/useApiClient.ts
    apps/web/src/client/hooks/useSessionEvents.ts
    apps/web/src/client/hooks/index.ts
  </files>
  <action>
Create React hooks for accessing the adapter:

1. **apps/web/src/client/hooks/useApiClient.ts:**
   ```typescript
   import type { WebElectronAPI } from '../types'

   /**
    * Access the HTTP adapter injected as window.electronAPI.
    * Throws if adapter not initialized (bootstrap error).
    */
   export function useApiClient(): WebElectronAPI {
     const api = (window as any).electronAPI as WebElectronAPI | undefined
     if (!api) {
       throw new Error('electronAPI not initialized. Ensure HttpAdapter is injected in main.tsx')
     }
     return api
   }
   ```

2. **apps/web/src/client/hooks/useSessionEvents.ts:**
   ```typescript
   import { useEffect, useCallback } from 'react'
   import type { SessionEvent } from '../types'

   /**
    * Subscribe to WebSocket session events with automatic cleanup.
    * Re-subscribes when sessionId changes.
    *
    * @param sessionId - Session to subscribe to (null to skip)
    * @param onEvent - Callback for events matching this session
    */
   export function useSessionEvents(
     sessionId: string | null,
     onEvent: (event: SessionEvent) => void
   ): void {
     const stableOnEvent = useCallback(onEvent, [onEvent])

     useEffect(() => {
       if (!sessionId) return

       const api = (window as any).electronAPI
       if (!api) {
         console.warn('[useSessionEvents] electronAPI not initialized')
         return
       }

       // Subscribe to session-scoped events
       api.subscribeToSession?.(sessionId)

       // Register global event handler that filters by sessionId
       const cleanup = api.onSessionEvent?.((event: SessionEvent) => {
         // Check if event has sessionId and matches
         if ('sessionId' in event && event.sessionId === sessionId) {
           stableOnEvent(event)
         }
         // config_changed events don't have sessionId, pass through
         if (event.type === 'config_changed') {
           stableOnEvent(event)
         }
       })

       return () => {
         cleanup?.()
         api.unsubscribeFromSession?.(sessionId)
       }
     }, [sessionId, stableOnEvent])
   }
   ```

3. **apps/web/src/client/hooks/index.ts:**
   ```typescript
   export { useApiClient } from './useApiClient'
   export { useSessionEvents } from './useSessionEvents'
   ```
  </action>
  <verify>
`bun run typecheck 2>&1 | grep -E "^apps/web"` - No type errors
`ls apps/web/src/client/hooks/` - Shows useApiClient.ts, useSessionEvents.ts, index.ts
  </verify>
  <done>useApiClient provides typed access to window.electronAPI, useSessionEvents subscribes to WebSocket events with cleanup on unmount</done>
</task>

<task type="auto">
  <name>Task 3: Update bootstrap and App to use adapter</name>
  <files>
    apps/web/src/client/main.tsx
    apps/web/src/client/App.tsx
  </files>
  <action>
Update the app entry point and main component:

1. **apps/web/src/client/main.tsx:**
   ```typescript
   import React from 'react'
   import { createRoot } from 'react-dom/client'
   import { HttpAdapter } from './adapters'
   import App from './App'

   // Inject HTTP adapter as window.electronAPI
   // This allows existing components expecting window.electronAPI to work unchanged
   const adapter = new HttpAdapter()
   ;(window as any).electronAPI = adapter

   // Connect WebSocket early
   adapter.connect()

   const container = document.getElementById('root')
   if (!container) {
     throw new Error('Root element not found')
   }

   const root = createRoot(container)
   root.render(
     <React.StrictMode>
       <App />
     </React.StrictMode>
   )
   ```

2. **apps/web/src/client/App.tsx:**
   ```typescript
   import React, { useState, useEffect, useCallback } from 'react'
   import { NetworkErrorBoundary, LoadingState } from './components'
   import { useApiClient } from './hooks'
   import type { SessionEvent } from './types'

   function AppContent() {
     const api = useApiClient()
     const [connectionStatus, setConnectionStatus] = useState<'disconnected' | 'connecting' | 'connected'>('disconnected')
     const [sessions, setSessions] = useState<any[]>([])
     const [workspaces, setWorkspaces] = useState<any[]>([])
     const [isLoading, setIsLoading] = useState(true)
     const [lastEvent, setLastEvent] = useState<SessionEvent | null>(null)
     const [error, setError] = useState<string | null>(null)

     // Fetch initial data
     useEffect(() => {
       async function loadData() {
         try {
           setIsLoading(true)
           setError(null)

           const [sessionsData, workspacesData] = await Promise.all([
             api.getSessions(),
             api.getWorkspaces()
           ])

           setSessions(sessionsData)
           setWorkspaces(workspacesData)
         } catch (err) {
           setError(err instanceof Error ? err.message : 'Failed to load data')
         } finally {
           setIsLoading(false)
         }
       }
       loadData()
     }, [api])

     // Subscribe to WebSocket events
     useEffect(() => {
       setConnectionStatus('connecting')

       const cleanup = api.onSessionEvent((event) => {
         setConnectionStatus('connected')
         setLastEvent(event)
         console.log('[App] WebSocket event:', event)
       })

       // Mark connected after subscription setup
       setTimeout(() => {
         // If no events received, still show as connected (WS open)
         setConnectionStatus('connected')
       }, 1000)

       return cleanup
     }, [api])

     const handleRetry = useCallback(() => {
       setError(null)
       setIsLoading(true)
       Promise.all([api.getSessions(), api.getWorkspaces()])
         .then(([s, w]) => {
           setSessions(s)
           setWorkspaces(w)
         })
         .catch((err) => setError(err.message))
         .finally(() => setIsLoading(false))
     }, [api])

     if (error) {
       return (
         <div style={{ padding: '20px', fontFamily: 'system-ui, sans-serif' }}>
           <h1>Craft Agents Web</h1>
           <div style={{ color: '#dc2626', marginBottom: '1rem' }}>Error: {error}</div>
           <button onClick={handleRetry} style={{ padding: '8px 16px' }}>Retry</button>
         </div>
       )
     }

     return (
       <div style={{ padding: '20px', fontFamily: 'system-ui, sans-serif' }}>
         <h1>Craft Agents Web</h1>

         <section style={{ marginBottom: '1.5rem' }}>
           <h2>Connection Status</h2>
           <p>WebSocket: <strong style={{
             color: connectionStatus === 'connected' ? '#16a34a' :
                    connectionStatus === 'connecting' ? '#ca8a04' : '#dc2626'
           }}>{connectionStatus}</strong></p>
           {lastEvent && (
             <p>Last event: <code style={{
               backgroundColor: '#f3f4f6',
               padding: '2px 6px',
               borderRadius: '4px'
             }}>{lastEvent.type}</code></p>
           )}
         </section>

         <LoadingState isLoading={isLoading} message="Loading data...">
           <section style={{ marginBottom: '1.5rem' }}>
             <h2>Workspaces ({workspaces.length})</h2>
             {workspaces.length === 0 ? (
               <p style={{ color: '#6b7280' }}>No workspaces found</p>
             ) : (
               <ul>
                 {workspaces.map((ws: any) => (
                   <li key={ws.id}>{ws.name || ws.id}</li>
                 ))}
               </ul>
             )}
           </section>

           <section>
             <h2>Sessions ({sessions.length})</h2>
             {sessions.length === 0 ? (
               <p style={{ color: '#6b7280' }}>No sessions found</p>
             ) : (
               <ul>
                 {sessions.map((s: any) => (
                   <li key={s.id}>{s.name || s.id}</li>
                 ))}
               </ul>
             )}
           </section>
         </LoadingState>
       </div>
     )
   }

   function App() {
     return (
       <NetworkErrorBoundary>
         <AppContent />
       </NetworkErrorBoundary>
     )
   }

   export default App
   ```
  </action>
  <verify>
`bun run typecheck 2>&1 | grep -E "^apps/web"` - No type errors
`grep "HttpAdapter" apps/web/src/client/main.tsx` - Adapter imported and instantiated
`grep "window.electronAPI" apps/web/src/client/main.tsx` - Adapter injected
  </verify>
  <done>main.tsx injects HttpAdapter as window.electronAPI and connects WebSocket, App.tsx fetches data with loading states and error handling</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete frontend adaptation with:
- HTTP adapter implementing WebElectronAPI via fetch calls
- WebSocket manager with auto-reconnect
- Loading states and error boundaries
- Bootstrap injecting adapter as window.electronAPI
- Demo app showing workspaces and sessions from server
  </what-built>
  <how-to-verify>
1. Start the server: `bun run web:dev`
2. Open browser to http://localhost:3000
3. Verify:
   - Page shows "Craft Agents Web" heading
   - "Loading data..." appears briefly (loading state works)
   - Workspaces section shows count (may be 0 if no workspaces exist)
   - Sessions section shows count (may be 0 if no sessions exist)
   - WebSocket status shows "connected" (green)
   - Browser console shows "[App] WebSocket event:" logs
4. Test error handling:
   - Stop the server (Ctrl+C)
   - Refresh page - should show "Connection Error" with "Try Again" button
   - Restart server, click "Try Again" - should recover
  </how-to-verify>
  <resume-signal>Type "approved" if verification passes, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependencies:**
   ```bash
   grep "react-error-boundary" apps/web/package.json
   # Should show dependency
   ```

2. **File Structure:**
   ```bash
   ls -la apps/web/src/client/components/
   ls -la apps/web/src/client/hooks/
   # Both should have expected files
   ```

3. **TypeScript:**
   ```bash
   bun run typecheck 2>&1 | grep -E "^apps/web" | head -5
   # Should show no errors
   ```

4. **Runtime Test:**
   ```bash
   bun run web:dev &
   sleep 3
   curl -s http://localhost:3000 | grep -o "Craft Agents Web" || echo "HTML served"
   curl -s http://localhost:3000/api/sessions | head -20
   kill %1
   ```
</verification>

<success_criteria>
- react-error-boundary installed in apps/web
- NetworkErrorBoundary catches fetch errors and shows retry UI
- LoadingState shows spinner during isLoading=true
- useApiClient provides typed access to window.electronAPI
- useSessionEvents subscribes with cleanup on unmount
- main.tsx creates HttpAdapter and injects as window.electronAPI
- App.tsx fetches sessions/workspaces and displays with loading state
- WebSocket connection status displayed
- Error boundary catches and displays network errors gracefully
- Human verification confirms app works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/06-frontend-adaptation/06-02-SUMMARY.md`
</output>
