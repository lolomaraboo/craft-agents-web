---
phase: 02-core-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/package.json
  - apps/web/src/server/index.ts
  - apps/web/src/server/routes/api/index.ts
  - apps/web/src/server/routes/api/sessions.ts
  - apps/web/src/server/schemas/session.ts
  - apps/web/src/server/schemas/common.ts
  - apps/web/src/server/lib/session-manager.ts
  - apps/web/src/server/plugins/cors.ts
autonomous: true

must_haves:
  truths:
    - "User can list all sessions via GET /api/sessions"
    - "User can create a session via POST /api/sessions"
    - "User can get a session with messages via GET /api/sessions/:id"
    - "User can delete a session via DELETE /api/sessions/:id"
    - "User can send a message via POST /api/sessions/:id/messages"
    - "User can abort processing via POST /api/sessions/:id/abort"
  artifacts:
    - path: "apps/web/src/server/routes/api/sessions.ts"
      provides: "Session REST endpoints"
      exports: ["sessionsRoutes"]
    - path: "apps/web/src/server/schemas/session.ts"
      provides: "TypeBox schemas for session requests/responses"
      exports: ["CreateSessionSchema", "SendMessageSchema", "SessionSchema"]
    - path: "apps/web/src/server/lib/session-manager.ts"
      provides: "SessionManager wrapper using @craft-agent/shared"
      exports: ["SessionManager"]
  key_links:
    - from: "apps/web/src/server/routes/api/sessions.ts"
      to: "apps/web/src/server/lib/session-manager.ts"
      via: "fastify.sessionManager decorator"
      pattern: "fastify\\.sessionManager\\."
    - from: "apps/web/src/server/index.ts"
      to: "apps/web/src/server/routes/api/index.ts"
      via: "route plugin registration"
      pattern: "register.*apiRoutes"
---

<objective>
Implement session CRUD endpoints and message handling for the web API layer.

Purpose: Replace Electron IPC session handlers (GET_SESSIONS, CREATE_SESSION, DELETE_SESSION, GET_SESSION_MESSAGES, SEND_MESSAGE, CANCEL_PROCESSING) with HTTP REST endpoints that the browser client can call.

Output: Fastify route plugin with TypeBox-validated endpoints for session management, connected to the existing @craft-agent/shared SessionManager.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-api/02-RESEARCH.md
@.planning/phases/01-server-foundation/01-01-SUMMARY.md
@.planning/phases/01-server-foundation/01-02-SUMMARY.md
@apps/web/src/server/index.ts
@apps/electron/src/shared/types.ts (Session interface, IPC_CHANNELS)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create CORS plugin</name>
  <files>apps/web/package.json, apps/web/src/server/plugins/cors.ts, apps/web/src/server/index.ts</files>
  <action>
Install required dependencies:
```bash
cd apps/web && bun add @sinclair/typebox @fastify/type-provider-typebox @fastify/cors
```

Create CORS plugin at apps/web/src/server/plugins/cors.ts:
- Use fastify-plugin wrapper (as per 01-01 pattern)
- Enable CORS only in development mode (process.env.NODE_ENV === 'development')
- Allow origin: 'http://localhost:5173' (Vite dev server)
- Allow credentials: true
- Allow methods: GET, POST, PUT, DELETE, PATCH, OPTIONS

Register CORS plugin in apps/web/src/server/index.ts BEFORE websocket plugin (order matters).

Why CORS: In dev mode, Vite (port 5173) and Fastify (port 3000) are on different origins. Browser blocks cross-origin requests without CORS headers.
  </action>
  <verify>
```bash
cd /opt/craft-agents-web && bun run tsc --noEmit -p apps/web/tsconfig.json
```
TypeScript compiles without errors.
  </verify>
  <done>CORS plugin exists and is registered in dev mode. Dependencies installed.</done>
</task>

<task type="auto">
  <name>Task 2: Create TypeBox schemas and SessionManager wrapper</name>
  <files>apps/web/src/server/schemas/common.ts, apps/web/src/server/schemas/session.ts, apps/web/src/server/lib/session-manager.ts</files>
  <action>
Create schemas directory and common schemas at apps/web/src/server/schemas/common.ts:
- ErrorResponseSchema: { error: string, details?: unknown }
- Use Type from @sinclair/typebox

Create session schemas at apps/web/src/server/schemas/session.ts:
- CreateSessionSchema: { workspaceId: string, permissionMode?: string, workingDirectory?: string }
- SendMessageSchema: { message: string, attachments?: array, storedAttachments?: array, options?: object }
- SessionSchema: Match Session interface from apps/electron/src/shared/types.ts
- Export Static types for TypeScript inference

Create SessionManager wrapper at apps/web/src/server/lib/session-manager.ts:
- Import from @craft-agent/shared/sessions (use existing session management)
- Create a class that wraps the shared session utilities
- Methods with stub return values:
  - getSessions(): returns Session[] - stub returns `[]` (empty array)
  - getSession(id): returns Session | null - stub returns mock session `{ id, workspaceId: 'mock', messages: [], createdAt: new Date().toISOString() }` or null if id === 'not-found'
  - createSession(workspaceId, options): returns Session - stub returns `{ id: crypto.randomUUID(), workspaceId, messages: [], createdAt: new Date().toISOString() }`
  - deleteSession(id): returns void - stub logs `Deleting session ${id}` and returns void
  - sendMessage(sessionId, message, ...): returns void - stub logs `Sending message to ${sessionId}` and returns void (Phase 3 will add event streaming)
  - cancelProcessing(sessionId): returns { success: boolean } - stub returns `{ success: true }`

Why stubs: The real SessionManager needs event callbacks for streaming responses. We'll wire those up in Phase 3 (Real-time Events). For Phase 2, we prove the HTTP layer works with predictable mock responses.
  </action>
  <verify>
```bash
cd /opt/craft-agents-web && bun run tsc --noEmit -p apps/web/tsconfig.json
```
TypeScript compiles. Schema types are correctly inferred.
  </verify>
  <done>TypeBox schemas defined. SessionManager wrapper created with stub implementations.</done>
</task>

<task type="auto">
  <name>Task 3: Create session routes and wire up to server</name>
  <files>apps/web/src/server/routes/api/sessions.ts, apps/web/src/server/routes/api/index.ts, apps/web/src/server/index.ts</files>
  <action>
Create routes directory structure:
```
apps/web/src/server/routes/
  api/
    index.ts      # Route plugin aggregator
    sessions.ts   # Session endpoints
```

Create sessions routes at apps/web/src/server/routes/api/sessions.ts:
- Use FastifyPluginAsync with TypeBoxTypeProvider
- Endpoints:
  - GET /sessions - List all sessions (returns Session[])
  - POST /sessions - Create session (body: CreateSessionSchema, returns 201 + Session)
  - GET /sessions/:id - Get session with messages (returns Session or 404)
  - DELETE /sessions/:id - Delete session (returns 204)
  - POST /sessions/:id/messages - Send message (body: SendMessageSchema, returns 202 Accepted)
  - POST /sessions/:id/abort - Cancel processing (returns 200 { success: boolean })
- Use schema validation on all endpoints
- Access SessionManager via fastify.sessionManager (will be decorated)
- Return appropriate HTTP status codes (201 created, 204 no content, 404 not found, 500 error)

Create API route aggregator at apps/web/src/server/routes/api/index.ts:
- Use fastify-plugin wrapper
- Register sessions routes under /api prefix
- Decorate fastify with sessionManager instance

Update apps/web/src/server/index.ts:
- Import and register apiRoutes plugin
- Register AFTER websocket plugin (so /api routes don't conflict with /ws)

Type augmentation for fastify.sessionManager:
- Add to routes/api/index.ts or a types file
- Declare module 'fastify' { interface FastifyInstance { sessionManager: SessionManager } }
  </action>
  <verify>
Start the dev server and test endpoints with curl:
```bash
# In one terminal
cd /opt/craft-agents-web && bun run web:dev &
sleep 3

# Test endpoints
curl http://localhost:3000/api/sessions
curl -X POST http://localhost:3000/api/sessions -H "Content-Type: application/json" -d '{"workspaceId": "test"}'
curl http://localhost:3000/api/sessions/test-id
curl -X DELETE http://localhost:3000/api/sessions/test-id
curl -X POST http://localhost:3000/api/sessions/test-id/messages -H "Content-Type: application/json" -d '{"message": "Hello"}'
curl -X POST http://localhost:3000/api/sessions/test-id/abort
```
All endpoints respond with appropriate status codes (200, 201, 202, 204, 404).
  </verify>
  <done>Session REST endpoints implemented and respond correctly. TypeBox validation active.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors: `bun run tsc --noEmit -p apps/web/tsconfig.json`
2. Server starts: `bun run web:dev` shows server listening
3. GET /api/sessions returns 200 with array
4. POST /api/sessions with valid body returns 201
5. POST /api/sessions with invalid body returns 400 (validation error)
6. GET /api/sessions/:id with unknown ID returns 404
7. DELETE /api/sessions/:id returns 204
8. POST /api/sessions/:id/messages returns 202
9. POST /api/sessions/:id/abort returns 200
10. CORS headers present in dev mode responses
</verification>

<success_criteria>
- All session CRUD endpoints functional (API-01)
- Message sending endpoint accepts requests (API-02)
- Abort endpoint functional (API-03)
- TypeBox validation rejects malformed requests with 400
- CORS enabled in development mode
- Server compiles and runs without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-api/02-01-SUMMARY.md`
</output>
