---
phase: 03-real-time-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/web/src/server/schemas/websocket.ts
  - apps/web/src/server/lib/websocket-events.ts
  - apps/web/src/server/plugins/websocket.ts
  - apps/web/src/server/lib/session-manager.ts
autonomous: true

must_haves:
  truths:
    - "WebSocket clients can subscribe to specific session events"
    - "Agent text_delta events are batched and broadcast to subscribed clients"
    - "Agent tool_start and tool_result events are broadcast to subscribed clients"
    - "Only clients subscribed to a session receive that session's events"
  artifacts:
    - path: "apps/web/src/server/schemas/websocket.ts"
      provides: "SessionEvent TypeBox schemas for all event types"
      contains: "text_delta|tool_start|tool_result|complete"
    - path: "apps/web/src/server/lib/websocket-events.ts"
      provides: "Session-scoped connection tracking and broadcast functions"
      exports: ["subscribeToSession", "unsubscribeFromSession", "broadcastToSession", "queueDelta", "flushDelta"]
    - path: "apps/web/src/server/lib/session-manager.ts"
      provides: "CraftAgent integration with event streaming"
      contains: "for await.*chatIterator"
  key_links:
    - from: "apps/web/src/server/plugins/websocket.ts"
      to: "apps/web/src/server/lib/websocket-events.ts"
      via: "import and register handlers"
      pattern: "subscribeToSession|unsubscribeFromSession"
    - from: "apps/web/src/server/lib/session-manager.ts"
      to: "apps/web/src/server/lib/websocket-events.ts"
      via: "broadcast calls during agent iteration"
      pattern: "broadcastToSession|queueDelta"
---

<objective>
Implement session-scoped WebSocket event broadcasting with delta batching for real-time agent streaming.

Purpose: Enable browser clients to receive agent response tokens, tool events, and completion signals in real-time as they occur, with proper session isolation.

Output: WebSocket event system that broadcasts CraftAgent events to subscribed clients with session-scoped filtering and 50ms delta batching.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-events/03-RESEARCH.md

# Prior phase context
@.planning/phases/02-core-api/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket event schemas and session-scoped tracking</name>
  <files>
    apps/web/src/server/schemas/websocket.ts
    apps/web/src/server/lib/websocket-events.ts
  </files>
  <action>
Create TypeBox schemas for all SessionEvent types in `schemas/websocket.ts`:
- `text_delta`: { type, sessionId, delta, turnId? }
- `text_complete`: { type, sessionId, text, isIntermediate?, turnId? }
- `tool_start`: { type, sessionId, toolName, toolUseId, toolInput, toolIntent?, toolDisplayName?, turnId? }
- `tool_result`: { type, sessionId, toolUseId, toolName, result, turnId?, isError? }
- `complete`: { type, sessionId }
- `error`: { type, sessionId, error }
- `permission_request`: { type, sessionId, request: { requestId, toolName, command, description } }
- `permission_response`: { type, requestId, allowed, alwaysAllow? } (client->server)
- `subscribe`: { type, sessionId } (client->server)
- `unsubscribe`: { type, sessionId } (client->server)
- `config_changed`: { type, changeType: 'config'|'theme' } (global broadcast)
- Use Type.Union for SessionEvent combining all types
- Export Static types for TypeScript inference

Create `lib/websocket-events.ts` with session-scoped connection tracking:
- `sessionClients: Map<string, Set<WebSocket>>` - tracks clients per session
- `socketSessions: WeakMap<WebSocket, Set<string>>` - tracks sessions per socket (for cleanup)
- `subscribeToSession(sessionId, socket)` - add socket to session tracking
- `unsubscribeFromSession(sessionId, socket)` - remove socket from session
- `cleanupSocket(socket)` - remove from all sessions on disconnect
- `broadcastToSession(sessionId, event)` - send to all clients in a session
- `broadcastGlobal(event)` - send to all connected clients (for config changes)

Implement delta batching (50ms intervals):
- `pendingDeltas: Map<string, { delta: string, turnId?: string }>`
- `deltaFlushTimers: Map<string, NodeJS.Timeout>`
- `queueDelta(sessionId, delta, turnId?)` - accumulate deltas, schedule flush
- `flushDelta(sessionId)` - send batched delta, clear timer

Export all functions and types for use by websocket plugin and session manager.
  </action>
  <verify>
```bash
cd /opt/craft-agents-web && bun run typecheck 2>&1 | grep -E "^apps/web" || echo "No web app type errors"
```
  </verify>
  <done>
WebSocket schemas define all event types with TypeBox. Session-scoped tracking and delta batching utilities are exported and type-safe.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate WebSocket event system with plugin and SessionManager</name>
  <files>
    apps/web/src/server/plugins/websocket.ts
    apps/web/src/server/lib/session-manager.ts
  </files>
  <action>
Update `plugins/websocket.ts`:
- Import websocket-events functions: subscribeToSession, unsubscribeFromSession, cleanupSocket, broadcastToSession, broadcastGlobal, queueDelta, flushDelta
- Decorate fastify instance with all broadcast functions (for use by routes and session manager)
- Update message handler to parse and handle:
  - `subscribe`: call subscribeToSession(message.sessionId, socket)
  - `unsubscribe`: call unsubscribeFromSession(message.sessionId, socket)
  - Log unknown message types at debug level
- Update close/error handlers to call cleanupSocket(socket)
- Declare TypeScript module augmentation for FastifyInstance with broadcast functions

Update `lib/session-manager.ts`:
- Add FastifyInstance parameter to constructor (for broadcast access)
- Import CraftAgent and AgentEvent from @craft-agent/shared/agent
- Store Fastify instance as private field
- Update sendMessage to be async and implement real event streaming:
  ```typescript
  async sendMessage(sessionId, message, attachments?, storedAttachments?, options?) {
    const agent = await this.getOrCreateAgent(sessionId)
    try {
      const chatIterator = agent.chat(message, attachments)
      for await (const event of chatIterator) {
        this.processAgentEvent(sessionId, event)
        if (event.type === 'complete') break
      }
    } catch (error) {
      // Broadcast error and complete events
      this.fastify.broadcastToSession(sessionId, { type: 'error', sessionId, error: error.message })
      this.fastify.broadcastToSession(sessionId, { type: 'complete', sessionId })
    }
  }
  ```
- Implement processAgentEvent(sessionId, event) that transforms AgentEvent to SessionEvent:
  - text_delta: call queueDelta for batching
  - text_complete: call flushDelta first, then broadcast text_complete
  - tool_start: broadcast directly with all fields
  - tool_result: broadcast directly with all fields
  - complete: broadcast complete event
  - error/typed_error: broadcast error event
  - permission_request: broadcast for Phase 3-02
- Add getOrCreateAgent stub (placeholder for now - returns mock agent that yields events)
- Note: Real CraftAgent integration requires workspace context; for now, create a mock async iterator that yields test events so the flow can be verified
  </action>
  <verify>
```bash
# Start server and test WebSocket subscription
cd /opt/craft-agents-web && timeout 5 bun run dev &
sleep 2
# Test WebSocket connection and subscription
node -e "
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:3000/ws');
ws.on('open', () => {
  console.log('Connected');
  ws.send(JSON.stringify({ type: 'subscribe', sessionId: 'test-session' }));
  setTimeout(() => { ws.close(); process.exit(0); }, 500);
});
ws.on('message', (data) => console.log('Received:', data.toString()));
ws.on('error', (e) => { console.error('Error:', e.message); process.exit(1); });
"
pkill -f "bun run dev" 2>/dev/null || true
```
  </verify>
  <done>
WebSocket plugin handles subscribe/unsubscribe messages. SessionManager processes agent events and broadcasts to subscribed clients. Server compiles and runs without errors.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors in apps/web
2. Server starts successfully with `bun run dev`
3. WebSocket client can connect and subscribe to sessions
4. SessionManager is wired to broadcast events (with mock agent for testing)
5. No memory leaks from session tracking (cleanup on disconnect)
</verification>

<success_criteria>
- [ ] WebSocket schemas define all SessionEvent types with TypeBox
- [ ] Session-scoped client tracking works (subscribe, unsubscribe, cleanup)
- [ ] Delta batching accumulates text_delta events (50ms flush)
- [ ] SessionManager transforms AgentEvent to SessionEvent
- [ ] Fastify instance decorated with broadcast functions
- [ ] Server starts and accepts WebSocket connections
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-events/03-01-SUMMARY.md`
</output>
