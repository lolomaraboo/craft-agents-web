---
phase: 03-real-time-events
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - apps/web/src/server/plugins/websocket.ts
  - apps/web/src/server/lib/session-manager.ts
  - apps/web/src/server/lib/config-watcher.ts
autonomous: true

must_haves:
  truths:
    - "Browser can respond to permission requests via WebSocket"
    - "Permission responses are correlated back to the requesting agent"
    - "Config change notifications broadcast to all connected clients"
    - "WebSocket reconnection restores session subscriptions"
  artifacts:
    - path: "apps/web/src/server/lib/session-manager.ts"
      provides: "Permission request/response handling with timeout"
      contains: "pendingPermissions|respondToPermission"
    - path: "apps/web/src/server/lib/config-watcher.ts"
      provides: "Config file watcher with broadcast integration"
      contains: "ConfigWatcher|onConfigChange"
    - path: "apps/web/src/server/plugins/websocket.ts"
      provides: "Permission response message handling"
      contains: "permission_response"
  key_links:
    - from: "apps/web/src/server/plugins/websocket.ts"
      to: "apps/web/src/server/lib/session-manager.ts"
      via: "permission response forwarding"
      pattern: "respondToPermission"
    - from: "apps/web/src/server/lib/config-watcher.ts"
      to: "apps/web/src/server/lib/websocket-events.ts"
      via: "broadcastGlobal for config changes"
      pattern: "broadcastGlobal"
---

<objective>
Implement bidirectional permission request/response flow and config change notifications.

Purpose: Complete real-time WebSocket infrastructure by enabling interactive permission dialogs and keeping clients informed of configuration changes.

Output: Permission handling that allows browser users to approve/deny agent tool executions, plus automatic config change notifications to all connected clients.
</objective>

<execution_context>
@/root/.claude/get-shit-done/workflows/execute-plan.md
@/root/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-real-time-events/03-RESEARCH.md

# Prior plan context
@.planning/phases/03-real-time-events/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement permission request/response flow in SessionManager</name>
  <files>
    apps/web/src/server/lib/session-manager.ts
    apps/web/src/server/plugins/websocket.ts
  </files>
  <action>
Update `lib/session-manager.ts` to handle permission requests:
- Add `pendingPermissions: Map<string, { resolve, sessionId, timeout }>` for tracking pending permission requests
- Add permission timeout constant: `PERMISSION_TIMEOUT_MS = 60000` (60 seconds)
- Update processAgentEvent to handle permission_request events:
  ```typescript
  case 'permission_request':
    // Store pending permission with timeout
    const timeoutId = setTimeout(() => {
      this.autoRejectPermission(event.requestId, sessionId)
    }, PERMISSION_TIMEOUT_MS)

    this.pendingPermissions.set(event.requestId, {
      resolve: null, // Will be set by CraftAgent callback
      sessionId,
      timeout: timeoutId
    })

    // Broadcast to clients
    this.fastify.broadcastToSession(sessionId, {
      type: 'permission_request',
      sessionId,
      request: {
        requestId: event.requestId,
        toolName: event.toolName,
        command: event.command,
        description: event.description
      }
    })
    break
  ```
- Add `respondToPermission(requestId, allowed, alwaysAllow?)` method:
  ```typescript
  respondToPermission(requestId: string, allowed: boolean, alwaysAllow?: boolean): void {
    const pending = this.pendingPermissions.get(requestId)
    if (!pending) {
      this.fastify.log.warn({ requestId }, 'Permission response for unknown request')
      return
    }

    clearTimeout(pending.timeout)
    this.pendingPermissions.delete(requestId)

    // Forward to CraftAgent (when properly wired)
    // For now, log the response
    this.fastify.log.info({ requestId, allowed, alwaysAllow }, 'Permission response received')
  }
  ```
- Add `autoRejectPermission(requestId, sessionId)` for timeout handling:
  ```typescript
  private autoRejectPermission(requestId: string, sessionId: string): void {
    const pending = this.pendingPermissions.get(requestId)
    if (!pending) return

    this.pendingPermissions.delete(requestId)
    this.fastify.log.warn({ requestId, sessionId }, 'Permission request timed out, auto-rejecting')

    // Broadcast timeout notification
    this.fastify.broadcastToSession(sessionId, {
      type: 'permission_timeout',
      sessionId,
      requestId
    })
  }
  ```

Update `plugins/websocket.ts` message handler:
- Add case for 'permission_response' message type:
  ```typescript
  case 'permission_response':
    if (message.requestId) {
      fastify.sessionManager.respondToPermission(
        message.requestId,
        message.allowed ?? false,
        message.alwaysAllow
      )
    }
    break
  ```
- Ensure sessionManager is accessible from the websocket handler
  </action>
  <verify>
```bash
cd /opt/craft-agents-web && bun run typecheck 2>&1 | grep -E "^apps/web" || echo "No web app type errors"
```
  </verify>
  <done>
Permission requests broadcast to subscribed clients. Permission responses route back to SessionManager. Timeout auto-rejects after 60 seconds.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config change notifications</name>
  <files>
    apps/web/src/server/lib/config-watcher.ts
    apps/web/src/server/index.ts
  </files>
  <action>
Create `lib/config-watcher.ts`:
- Import ConfigWatcher and callbacks from @craft-agent/shared/config
- Import broadcastGlobal from websocket-events
- Create setup function that initializes ConfigWatcher:
  ```typescript
  import { createConfigWatcher, type ConfigWatcherCallbacks } from '@craft-agent/shared/config'
  import { broadcastGlobal } from './websocket-events.js'
  import type { FastifyInstance } from 'fastify'

  let watcher: ReturnType<typeof createConfigWatcher> | null = null

  export async function setupConfigWatcher(fastify: FastifyInstance): Promise<void> {
    const callbacks: ConfigWatcherCallbacks = {
      onConfigChange: (config) => {
        fastify.log.info('Config changed, broadcasting to clients')
        broadcastGlobal({ type: 'config_changed', changeType: 'config' })
      },
      onThemeChange: (theme) => {
        fastify.log.info('Theme changed, broadcasting to clients')
        broadcastGlobal({ type: 'config_changed', changeType: 'theme' })
      }
    }

    watcher = createConfigWatcher(callbacks)
    await watcher.start()

    fastify.log.info('Config watcher started')
  }

  export async function stopConfigWatcher(): Promise<void> {
    if (watcher) {
      await watcher.stop()
      watcher = null
    }
  }
  ```
- Handle case where ConfigWatcher is not available (graceful fallback)

Update `server/index.ts`:
- Import setupConfigWatcher and stopConfigWatcher
- Call setupConfigWatcher after server is ready (in onReady hook or after listen)
- Call stopConfigWatcher in shutdown handler

Add permission_timeout to schemas/websocket.ts (if not already present):
- `permission_timeout`: { type, sessionId, requestId }
  </action>
  <verify>
```bash
# Start server and verify config watcher initializes
cd /opt/craft-agents-web && timeout 5 bun run dev 2>&1 | grep -i "config watcher" && echo "Config watcher OK" || echo "Config watcher may not be logging (check implementation)"
pkill -f "bun run dev" 2>/dev/null || true
```
  </verify>
  <done>
Config watcher broadcasts changes to all connected WebSocket clients. Server initializes watcher on startup and stops it on shutdown.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Server starts with config watcher initialized
3. Permission flow: request -> broadcast -> response -> acknowledgment
4. Config changes broadcast to all connected clients
5. Permission timeout auto-rejects after 60 seconds
</verification>

<success_criteria>
- [ ] Permission requests broadcast to subscribed session clients
- [ ] Permission responses route from WebSocket to SessionManager
- [ ] Permission timeout (60s) auto-rejects and notifies client
- [ ] Config watcher broadcasts config_changed events to all clients
- [ ] Server gracefully starts/stops config watcher
- [ ] All event types have TypeBox schemas
</success_criteria>

<output>
After completion, create `.planning/phases/03-real-time-events/03-02-SUMMARY.md`
</output>
